<style>
    h1#firstHeading {
        margin-bottom: 0px;
    }
</style>



<style>
    #toc,
    .toc {
        padding: 1em 1em;
        border: 1px solid #dddddd;
        display: inline-block;
        width: auto;
        margin: 1.5em 0;
    }
</style>


<!DOCTYPE html>
<html xmlns:og="og: http://ogp.me/ns#">

<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <title>Research MachineLearning MapReduce | Big Data Analytics Lab</title>
    <!--페이지 제목-->

    <meta name="author" content="username" />

    <meta name="title" content="Members" />
    <link rel="icon" type="image/png" href="http://localhost:4000/favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta property="og:title" content="Members" />
    <meta name="twitter:title" content="Members" />

    <meta name="keywords" content="Big-Data," />

    <link rel="canonical" href="http://example.com/" />
    <meta property="og:site_name" content="Big Data Analytics Lab" />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="http://example.com" />
    <meta name="description" content="Big Data Analytics Lab" />
    <meta property="og:description" content="Big Data Analytics Lab" />
    <meta name="twitter:description" content="Big Data Analytics Lab" />

    <meta property="og:image" content="http://example.com/sharer.png" />
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:image" content="http://example.com/sharer.png" />
    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" />
</head>

<body class="wrap">
    <header>
        <nav class="main-nav">
            <a href="#" class="opener show-on-mobiles">...</a>
            <div class="clear-opener show-on-mobiles"></div>
            <div class="grid">
                <ul>
                    <li>
                        <h1 class="site-title"><a href="/">Big Data Analytics Lab</a></h1>
                    </li>
                    >
                    <li>
                        <a href="/"><i class="fa fa-home"></i>Main Page</a>
                    </li>
                    <li>
                        <a href="/members"><i class="fa fa-info-circle"></i>Members</a>
                    </li>
                    <li>
                        <a href="/research"><i class="fa fa-check"></i>Research</a>
                    </li>
                    <li>
                        <a href="/publication"><i class="fa fa-star"></i>Publication</a>
                    </li>
                </ul>
            </div>
        </nav>
    </header>

    <section class="content">
        <div id="home" class="grid post">
            <div class="unit whole">
                <h1 id="firstHeading" class="title">Map Reduce</h1>
                <!--내용 제목-->
                <p><em>From Big Data Analytics Lab</em></p>

                <div class="row">
                    <div id="p-cactions" class="large-12 columns">
                        <div id="content">
                            <h5 id="siteSub" class="subtitle"></h5>
                            <div id="contentSub" class="clear_both"></div>
                            <div id="bodyContent" class="mw-bodytext">
                                <div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr">
                                    <div class="mw-parser-output">
                                        <p><big><b>MapReduce: Simplified Data Processing on Large Clusters</b></big>
                                        </p>
                                        <p>Jeffrey Dean and Sanjay Ghemawat. MapReduce: Simplified Data Processing on
                                            Large Clusters. Sixth Symposium on Operating System Design and
                                            Implementation (OSDI '04), San Francisco, CA, December, 2004.
                                        </p>
                                        <div id="toc" class="toc">
                                            <div class="toctitle">
                                                <h2 style="margin-top: 0px;">Contents</h2><span
                                                    class="toctoggle">&nbsp;[<a role="button" tabindex="0"
                                                        class="togglelink">hide</a>]&nbsp;</span>
                                            </div>
                                            <ul>
                                                <li class="toclevel-1 tocsection-1"><a href="#Introduction"><span
                                                            class="tocnumber">1</span> <span
                                                            class="toctext">Introduction</span></a></li>
                                                <li class="toclevel-1 tocsection-2"><a href="#Programming_Model"><span
                                                            class="tocnumber">2</span> <span class="toctext">Programming
                                                            Model</span></a>
                                                    <ul>
                                                        <li class="toclevel-2 tocsection-3"><a
                                                                href="#Example_-_word_counting"><span
                                                                    class="tocnumber">2.1</span> <span
                                                                    class="toctext">Example - word counting</span></a>
                                                        </li>
                                                        <li class="toclevel-2 tocsection-4"><a href="#Types"><span
                                                                    class="tocnumber">2.2</span> <span
                                                                    class="toctext">Types</span></a></li>
                                                        <li class="toclevel-2 tocsection-5"><a
                                                                href="#More_Examples"><span class="tocnumber">2.3</span>
                                                                <span class="toctext">More Examples</span></a></li>
                                                    </ul>
                                                </li>
                                                <li class="toclevel-1 tocsection-6"><a href="#Implementation"><span
                                                            class="tocnumber">3</span> <span
                                                            class="toctext">Implementation</span></a>
                                                    <ul>
                                                        <li class="toclevel-2 tocsection-7"><a
                                                                href="#Execution_Overview"><span
                                                                    class="tocnumber">3.1</span> <span
                                                                    class="toctext">Execution Overview</span></a></li>
                                                        <li class="toclevel-2 tocsection-8"><a
                                                                href="#Master_Data_Structures"><span
                                                                    class="tocnumber">3.2</span> <span
                                                                    class="toctext">Master Data Structures</span></a>
                                                        </li>
                                                        <li class="toclevel-2 tocsection-9"><a
                                                                href="#Fault_Tolerance"><span
                                                                    class="tocnumber">3.3</span> <span
                                                                    class="toctext">Fault Tolerance</span></a>
                                                            <ul>
                                                                <li class="toclevel-3 tocsection-10"><a
                                                                        href="#Worker_Failure"><span
                                                                            class="tocnumber">3.3.1</span> <span
                                                                            class="toctext">Worker Failure</span></a>
                                                                </li>
                                                                <li class="toclevel-3 tocsection-11"><a
                                                                        href="#Master_Failure"><span
                                                                            class="tocnumber">3.3.2</span> <span
                                                                            class="toctext">Master Failure</span></a>
                                                                </li>
                                                                <li class="toclevel-3 tocsection-12"><a
                                                                        href="#Semantics_in_the_Presence_of_Failures"><span
                                                                            class="tocnumber">3.3.3</span> <span
                                                                            class="toctext">Semantics in the Presence of
                                                                            Failures</span></a></li>
                                                            </ul>
                                                        </li>
                                                        <li class="toclevel-2 tocsection-13"><a href="#Locality"><span
                                                                    class="tocnumber">3.4</span> <span
                                                                    class="toctext">Locality</span></a></li>
                                                        <li class="toclevel-2 tocsection-14"><a
                                                                href="#Task_Granularity"><span
                                                                    class="tocnumber">3.5</span> <span
                                                                    class="toctext">Task Granularity</span></a></li>
                                                        <li class="toclevel-2 tocsection-15"><a
                                                                href="#Backup_Tasks"><span class="tocnumber">3.6</span>
                                                                <span class="toctext">Backup Tasks</span></a></li>
                                                    </ul>
                                                </li>
                                                <li class="toclevel-1 tocsection-16"><a href="#Refinements"><span
                                                            class="tocnumber">4</span> <span
                                                            class="toctext">Refinements</span></a>
                                                    <ul>
                                                        <li class="toclevel-2 tocsection-17"><a
                                                                href="#Partitioning_Function"><span
                                                                    class="tocnumber">4.1</span> <span
                                                                    class="toctext">Partitioning Function</span></a>
                                                        </li>
                                                        <li class="toclevel-2 tocsection-18"><a
                                                                href="#Ordering_Guarantees"><span
                                                                    class="tocnumber">4.2</span> <span
                                                                    class="toctext">Ordering Guarantees</span></a></li>
                                                        <li class="toclevel-2 tocsection-19"><a
                                                                href="#Combiner_Function"><span
                                                                    class="tocnumber">4.3</span> <span
                                                                    class="toctext">Combiner Function</span></a></li>
                                                        <li class="toclevel-2 tocsection-20"><a
                                                                href="#Input_and_Output_Types"><span
                                                                    class="tocnumber">4.4</span> <span
                                                                    class="toctext">Input and Output Types</span></a>
                                                        </li>
                                                        <li class="toclevel-2 tocsection-21"><a
                                                                href="#Side-effects"><span class="tocnumber">4.5</span>
                                                                <span class="toctext">Side-effects</span></a></li>
                                                        <li class="toclevel-2 tocsection-22"><a
                                                                href="#Skipping_Bad_Records"><span
                                                                    class="tocnumber">4.6</span> <span
                                                                    class="toctext">Skipping Bad Records</span></a></li>
                                                        <li class="toclevel-2 tocsection-23"><a
                                                                href="#Local_Execution"><span
                                                                    class="tocnumber">4.7</span> <span
                                                                    class="toctext">Local Execution</span></a></li>
                                                        <li class="toclevel-2 tocsection-24"><a
                                                                href="#Status_Information"><span
                                                                    class="tocnumber">4.8</span> <span
                                                                    class="toctext">Status Information</span></a></li>
                                                        <li class="toclevel-2 tocsection-25"><a href="#Counters"><span
                                                                    class="tocnumber">4.9</span> <span
                                                                    class="toctext">Counters</span></a></li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </div>

                                        <h1><span class="mw-headline" id="Introduction">Introduction</span></h1>
                                        <ul>
                                            <li> Google에는 방대한 양의 raw data를 가공해서 필요한 결과를 만들어야 하는 연산들이 많이 존재.
                                                <ul>
                                                    <li> input: 수집된 문서들, 웹 요청 로그 등</li>
                                                    <li> output: inverted indices, 웹 문서들 간의 그래프 구조 표현, host 당 수집된 페이지 수
                                                        정보, 특정 기간동안 가장 빈번한 질의 등</li>
                                                </ul>
                                            </li>
                                            <li> 원래의 계산 자체는 straightforward한데 데이터 분산, 병렬 계산, 실패 처리, 부하 분산 등으로 인해 문제가
                                                복잡해짐.</li>
                                            <li> 이러한 복잡성을 숨기는 새로운 abstraction 고안.
                                                <ul>
                                                    <li> LISP 등 functional language의 map/reduce 함수로부터 영향.</li>
                                                    <li> 대부분의 연산이 input의 각 logical "record"에 map 연산을 적용해서 중간 결과
                                                        key/value 집합을 만든 뒤, 같은 key 값의 모든 value들에 대해 reduce 연산을 적용해서 합산한
                                                        결과를 얻을 수 있겠더라.</li>
                                                    <li> 병렬화도 쉽고 연산이 실패한 경우에도 map/reduce 연산을 재실행하기만 하면 됨.</li>
                                                </ul>
                                            </li>
                                            <li> 자동으로 병렬 처리 및 대규모 연산을 분산해 주는 단순하고 강력한 인터페이스 탄생. MapReduce.</li>
                                        </ul>
                                        <h1><span class="mw-headline" id="Programming_Model">Programming Model</span>
                                        </h1>
                                        <p>사용자는 하고자 하는 연산을 Map, Reduce 2가지 함수로 표현하면 됨.
                                        </p>
                                        <ul>
                                            <li> Map: input key/value pair들을 받아서 중간 key/value pair를 생성. </li>
                                            <li> MapReduce 라이브러리는 같은 key 값의 모든 중간 결과를 묶어서 Reduce 함수로 보냄.</li>
                                            <li> Reduce: 특정 중간 key 값을 갖는 value들을 input으로 받아서 이를 합하여 결과 값(들의 집합)을 생성.
                                            </li>
                                            <li> 중간 값들은 iterator를 통해 reduce 함수로 공급. 메모리에 담을 수 있는 정도의 크기로 보냄.</li>
                                            <li> Map함수의 input key, value 타입은 사용자가 프로그램에서 지정.</li>
                                        </ul>
                                        <h2><span class="mw-headline" id="Example_-_word_counting">Example - word
                                                counting</span></h2>
                                        <p><a href="/index.php/File:MR_ExampleWC.png" class="image"
                                                title="Example - word counting"><img alt="Example - word counting"
                                                    src="/images/3/3d/MR_ExampleWC.png" width="327" height="236"></a>
                                        </p>
                                        <ul>
                                            <li> map/reduce 함수 이외에, input/output 파일명, 부가적인 tuning 파라미터 등 실행에 필요한 코드 작성해야
                                                함.</li>
                                        </ul>
                                        <h2><span class="mw-headline" id="Types">Types</span></h2>
                                        <ul>
                                            <li> map (k1, v1) -&gt; list(k2, v2) &nbsp;: map의 input과 output key/value의
                                                domain은 달라짐.</li>
                                            <li> reduce (k2, list(v2)) -&gt; list (v2) &nbsp;: reduce의 input과 output
                                                key/value의 domain은 같음.</li>
                                        </ul>
                                        <h2><span class="mw-headline" id="More_Examples">More Examples</span></h2>
                                        <ul>
                                            <li> distributed grep
                                                <ul>
                                                    <li> map - input: 문서 / output: 지정한 패턴이 있는 라인</li>
                                                    <li> reduce - output: 중간 결과 라인 그대로 copy</li>
                                                </ul>
                                            </li>
                                            <li> count of URL access frequency (word count랑 비슷)
                                                <ul>
                                                    <li> map - input: 웹 페이지 요청 로그 / output: &lt;URL, 1&gt;</li>
                                                    <li> reduce - output: &lt;URL, total count&gt;</li>
                                                </ul>
                                            </li>
                                            <li> reverse web-link graph
                                                <ul>
                                                    <li> map - input: source 웹 페이지 / output: &lt;target, source&gt;
                                                        (target은 source 내에서 찾은 link의 URL)</li>
                                                    <li> reduce - output: &lt;target, list(source)&gt; </li>
                                                </ul>
                                            </li>
                                            <li> term-vector per host
                                                <ul>
                                                    <li> term-vector: &lt;word, frequency&gt; pair의 리스트.</li>
                                                    <li> map - input: 웹 문서 / output: &lt;hostname, term vector&gt;
                                                        (hostname은 URL에서 추출)</li>
                                                    <li> reduce - output: &lt;hostname, term vector&gt; 모든 term vector에서
                                                        자주 나오는 중요한 term만 남김.</li>
                                                </ul>
                                            </li>
                                            <li> inverted index
                                                <ul>
                                                    <li> map - input: 문서 / output: &lt;word, document ID&gt;</li>
                                                    <li> reduce - output: &lt;word, list(document ID)&gt;</li>
                                                </ul>
                                            </li>
                                            <li> distributed sort
                                                <ul>
                                                    <li> map - output: &lt;key, record&gt; input의 각 record로부터 key를 추출.
                                                    </li>
                                                    <li> reduce - output: 중간 결과 그대로. reduce의 input으로 중간 결과를 보내기 전에
                                                        partitioning &amp; 중간 결과 sort 됨.</li>
                                                </ul>
                                            </li>
                                        </ul>
                                        <h1><span class="mw-headline" id="Implementation">Implementation</span></h1>
                                        <ul>
                                            <li> 환경에 따라 MapReduce 인터페이스 구현이 달라질 수 있다.</li>
                                            <li> Google은 다음의 환경에 맞추어 구현.</li>
                                        </ul>
                                        <ol>
                                            <li> 각 머신은 2~4GB 메모리, 듀얼 프로세서 x86 프로세서를 갖는 리눅스 머신이다.</li>
                                            <li> 시중의 네트워크 하드웨어 사용 - 100Mb/s 또는 1Gb/s</li>
                                            <li> 클러스터는 수백, 수천 대의 머신으로 이루어지므로 failure는 일상적이다.</li>
                                            <li> 저장소도 비싸지 않은 IDE 디스크 사용. (파일 시스템에서 replication을 통해 availability,
                                                reliability 제공)</li>
                                            <li> 사용자는 스케쥴링 시스템에 job을 요청. 각 job은 여러 task로 나뉘고 스케쥴러가 클러스터의 여러 머신에 나누어줌
                                            </li>
                                        </ol>
                                        <h2><span class="mw-headline" id="Execution_Overview">Execution Overview</span>
                                        </h2>
                                        <ul>
                                            <li> map: input은 자동으로 M개의 split으로 나뉘고, 그에 따라 병렬 호출.</li>
                                            <li> reduce: 중간 key를 파티셔닝 함수를 이용하여 R개로 중간 결과를 나누고 병렬 호출. 파티셔닝 함수와 파티션 개수(R)는
                                                사용자가 지정.</li>
                                        </ul>
                                        <p><a href="/index.php/File:MR_ExecutionOverview.png" class="image"
                                                title="Execution Overview"><img alt="Execution Overview"
                                                    src="/images/7/74/MR_ExecutionOverview.png" width="667"
                                                    height="520"></a>
                                        </p>
                                        <ol>
                                            <li> 사용자 프로그램에 링크된 MapReduce 라이브러리가 input 파일들을 M개의 split(보통 16~64MB)으로 나눈다.
                                                (옵션으로 조정 가능) 클러스터의 머신들에 다수의 프로그램 copy를 띄운다.</li>
                                            <li> 프로그램 copy들 중 하나가 master가 되고 나머지는 master에게 일을 할당받는 worker가 된다. master는
                                                idle 상태의 worker에게 map task 또는 reduce task를 할당하는 역할을 한다.</li>
                                            <li> map task를 할당받은 worker는 해당하는 input split의 내용을 읽고 key/value pair를
                                                parsing해서 사용자가 정의한 Map 함수에 넘겨준다. Map 함수의 output인 중간 결과는 메모리 버퍼에 둔다.</li>
                                            <li> 주기적으로 버퍼에 있는 중간 결과를 local disk에 쓰는데, partitioning 함수에 따라 R개의 region으로
                                                나누어 쓴다. local disk에 쓰인 중간 결과의 위치는 마스터에게 전달된다.</li>
                                            <li> reduce worker는 master가 이 중간 결과의 위치를 알려주면, RPC를 수행하여 map worker의 local
                                                disk로부터 중간 결과를 읽는다. 모든 중간 결과를 다 읽으면 key 값에 따라 정렬하여 같은 key 값을 갖는 결과를 모은다.
                                                (한 reduce task가 여러 개의 key 값을 가진 데이터를 처리할 수도 있으므로)</li>
                                            <li> reduce worker는 정렬된 중간 결과를 각 key 값에 해당하는 중간 결과를 Reduce 함수에 넘겨준다. Reduce
                                                함수의 output은 해당 reduce 파티션에 대한 최종 output file에 append된다.</li>
                                            <li> 모든 map task와 reduce task가 끝나면 master는 사용자 프로그램을 깨운다.</li>
                                        </ol>
                                        <ul>
                                            <li> 성공적으로 MapReduce가 수행되고 나면 R개의 output file이 남는다. (각 reduce task 당 하나)
                                            </li>
                                            <li> output이 다시 다른 MapReduce 또는 분산 어플리케이션의 input으로 사용되기도 하므로 꼭 하나로 모을 필요는
                                                없다.</li>
                                        </ul>
                                        <h2><span class="mw-headline" id="Master_Data_Structures">Master Data
                                                Structures</span></h2>
                                        <ul>
                                            <li> master가 유지하는 자료 구조
                                                <ul>
                                                    <li> 각 map/reduce task의 상태: idle, in-progress, completed</li>
                                                    <li> worker 머신의 identity</li>
                                                    <li> map task의 output 중간 결과의 위치
                                                        <ul>
                                                            <li> reduce worker에 전달됨</li>
                                                            <li> master는 map task가 끝날 때 중간 결과의 위치와 크기 정보에 대한 update를 받고
                                                                in-progress 상태의 reduce task를 가진 worker에게 incremental하게
                                                                push한다.</li>
                                                        </ul>
                                                    </li>
                                                </ul>
                                            </li>
                                        </ul>
                                        <h2><span class="mw-headline" id="Fault_Tolerance">Fault Tolerance</span></h2>
                                        <h3><span class="mw-headline" id="Worker_Failure">Worker Failure</span></h3>
                                        <ul>
                                            <li> master가 주기적으로 모든 worker에게 ping을 날림. 일정 시간 지나도록 응답이 없으면 worker를 failed로
                                                표시. </li>
                                            <li> 해당 worker에 의해 수행된 map task: in-progress, completed 상태인 task를 idle 상태로
                                                되돌려서 다른 worker에게 할당.
                                                <ul>
                                                    <li> completed라도 다시 수행하는 이유 - map task의 중간 결과는 worker의 local disk에
                                                        쓰여 있어서 접근하지 못하므로.</li>
                                                </ul>
                                            </li>
                                            <li> 해당 worker에 의해 수행된 reduce task: in-progress 상태인 task만 idle 상태로 되돌려서 다른
                                                worker에게 할당.
                                                <ul>
                                                    <li> reduce task의 output은 최종 output file에 쓰이므로 완료된 것은 괜찮음.</li>
                                                </ul>
                                            </li>
                                            <li> 다시 수행하기만 하면 되니까 매우 견고하다.</li>
                                        </ul>
                                        <h3><span class="mw-headline" id="Master_Failure">Master Failure</span></h3>
                                        <ul>
                                            <li> master의 자료구조를 주기적으로 checkpoint. 죽었을 경우 ckpt부터만 다시 하면 됨.</li>
                                            <li> 실제 구현은 master가 죽으면 그냥 전체 실행 실패. 사용자가 다시 재실행.
                                                <ul>
                                                    <li> master는 딱 하나이기 때문에 죽을 가능성이 거의 없음. (하나 중에 하나 죽는 가능성 vs. 수백개 중에
                                                        하나 죽는 가능성)</li>
                                                </ul>
                                            </li>
                                        </ul>
                                        <h3><span class="mw-headline"
                                                id="Semantics_in_the_Presence_of_Failures">Semantics in the Presence of
                                                Failures</span></h3>
                                        <ul>
                                            <li> map/reduce 함수가 deterministic하면, MapReduce 프로그램의 결과는 전체 프로그램을
                                                sequential하게 수행한 것과 결과가 같다.</li>
                                            <li> non-deterministic한 경우에도, 좀 약하긴 하지만 괜찮은 semantics를 가짐.
                                                <ul>
                                                    <li> 어떤 reduce task R1의 output은 프로그램을 sequential하게 수행한 어떤 R1의
                                                        output과 같다.</li>
                                                    <li> 어떤 reduce task R2의 output은 프로그램을 sequential하게 수행한 어떤 R2의
                                                        output과 같다. </li>
                                                    <li> 하지만, 두 sequential 수행은 서로 다르다는 거..</li>
                                                </ul>
                                            </li>
                                        </ul>
                                        <h2><span class="mw-headline" id="Locality">Locality</span></h2>
                                        <ul>
                                            <li> 클러스터에서는 network bandwidth가 중요한 자원임.</li>
                                            <li> GFS가 input data를 여러 머신의 local disk에 복제해 놓음.</li>
                                            <li> master가 이 위치 정보를 이용해서 map task를 input data의 replica가 존재하는 머신 혹은 가까운
                                                머신(같은 스위치 내)에 할당 시도.</li>
                                        </ul>
                                        <h2><span class="mw-headline" id="Task_Granularity">Task Granularity</span></h2>
                                        <ul>
                                            <li> 이상적으로는 map task의 개수(M)와 reduce task의 개수(R)가 훨씬 커야 좋다.
                                                <ul>
                                                    <li> dynamic load balancing, fast recovery 때문</li>
                                                </ul>
                                            </li>
                                            <li> 제약
                                                <ul>
                                                    <li> master의 scheduling decision: O(M+R)</li>
                                                    <li> master가 메모리에 유지해야 하는 자료구조 크기: O(M*R) (map output이 R개라서인듯)</li>
                                                </ul>
                                            </li>
                                            <li> 보통 M은 locality를 위해 한 input data가 16~64MB가 되도록 정함. (GFS의 chunk 크기에
                                                맞추겠지.) R은 worker의 몇배 정도..(output 파일의 개수이기도 함)
                                                <ul>
                                                    <li> e.g., M=200,000 / R=5,000 / worker = 2,000 </li>
                                                </ul>
                                            </li>
                                        </ul>
                                        <h2><span class="mw-headline" id="Backup_Tasks">Backup Tasks</span></h2>
                                        <ul>
                                            <li> 이상하게 느린 머신("straggler") 때문에 마지막 몇 개의 map/reduce task가 오래 걸려서 전체 수행 시간이
                                                길어지는 경우가 발생.
                                                <ul>
                                                    <li> bad disk, 머신 설정(cache가 꺼졌다던가..) 등 때문에 이런 일들이 발생할 수 있음.</li>
                                                </ul>
                                            </li>
                                            <li> 전체 과정이 거의 끝나갈 무렵이 되면, 이미 수행 중인 task라도 backup으로 다른 worker에게 할당해서 수행시킴.
                                                아무 worker나 먼저 끝내면 그걸로 완료시킴.</li>
                                        </ul>
                                        <h1><span class="mw-headline" id="Refinements">Refinements</span></h1>
                                        <h2><span class="mw-headline" id="Partitioning_Function">Partitioning
                                                Function</span></h2>
                                        <ul>
                                            <li> 사용자가 reduce task의 개수(= output file의 개수) R을 지정.</li>
                                            <li> 중간 결과의 key에 partitioning function을 사용해서 나누게 됨.</li>
                                            <li> default: hash(key) mod R, 필요에 따라 바꿔서 사용 가능.</li>
                                        </ul>
                                        <h2><span class="mw-headline" id="Ordering_Guarantees">Ordering
                                                Guarantees</span></h2>
                                        <ul>
                                            <li> 특정 partition 내에서는 중간 key/value pair들이 오름차순으로 처리됨.</li>
                                            <li> partition별로 정렬된 output file을 생성하기 쉬움.</li>
                                        </ul>
                                        <h2><span class="mw-headline" id="Combiner_Function">Combiner Function</span>
                                        </h2>
                                        <ul>
                                            <li> map task에 의해 생성된 중간 결과에는 key가 중복됨.</li>
                                            <li> reduce 함수가 commutative &amp; associative한 경우 중간 결과를 merge해서 보낼 수 있음.
                                                <ul>
                                                    <li> word count example: &lt;the, 1&gt;, &lt;the, 1&gt;, &lt;the,
                                                        1&gt;, &lt;the, 1&gt; -&gt; &lt;the, 4&gt;</li>
                                                </ul>
                                            </li>
                                            <li> combiner 함수는 보통 reduce 함수와 동일. output이 최종 output file에 쓰이지 않고 중간 결과로 다시
                                                reduce task의 input이 된다는 점이 다름.</li>
                                        </ul>
                                        <h2><span class="mw-headline" id="Input_and_Output_Types">Input and Output
                                                Types</span></h2>
                                        <ul>
                                            <li> input type: text file에서 offset으로 key &amp; value 지정. key/value sequence
                                                등.</li>
                                            <li> 사용자가 reader interface를 구현하면 새로운 input type 지원됨.</li>
                                            <li> 꼭 file일 필요는 없음. DB로부터 record를 읽는다던가 메모리에 있는 자료구조에서 읽는다던가...</li>
                                            <li> output도 마찬가지...</li>
                                        </ul>
                                        <h2><span class="mw-headline" id="Side-effects">Side-effects</span></h2>
                                        <ul>
                                            <li> Map, reduce operator에서 aux file을 생성하는게 유용할때도 있다.</li>
                                            <li> 그런데 이 경우 programmer가 atomic하고 idempotent하게 수행되도록 잘 생각해야 한다.
                                                <ul>
                                                    <li> temp file을 쓰고 마지막에 rename을 한다던지...</li>
                                                </ul>
                                            </li>
                                            <li> 여러 파일을 output 하려면 2-phase commit을 해야 되는데 그런건 제공하지 않는다.
                                                <ul>
                                                    <li> Q) 왜 2-phase commit을 해야되나?</li>
                                                </ul>
                                            </li>
                                        </ul>
                                        <h2><span class="mw-headline" id="Skipping_Bad_Records">Skipping Bad
                                                Records</span></h2>
                                        <ul>
                                            <li> Map, Reduce function이 특정 record를 처리 할 때 버그로 인해 죽는 경우, 해당 record만 넘길 수
                                                있도록 하는 실행 모드가 있다.</li>
                                            <li> signal handler를 이용해 user code가 죽으면 signal handler가 master에게 packet을
                                                보낸다.</li>
                                            <li> master는 다음에 재 실행할때에 그 record를 건너 뛰라고 지시한다.</li>
                                        </ul>
                                        <h2><span class="mw-headline" id="Local_Execution">Local Execution</span></h2>
                                        <ul>
                                            <li> 디버깅을 위해 local에서 실행해 볼 수 있음</li>
                                        </ul>
                                        <h2><span class="mw-headline" id="Status_Information">Status Information</span>
                                        </h2>
                                        <ul>
                                            <li> master가 web server를 통해 status page를 제공
                                                <ul>
                                                    <li> 몇개의 task가 끝났나, 혹은 진행중인가.</li>
                                                    <li> 중간 데이터의 크기</li>
                                                    <li> 진행 속도 등</li>
                                                </ul>
                                            </li>
                                        </ul>
                                        <h2><span class="mw-headline" id="Counters">Counters</span></h2>
                                        <ul>
                                            <li> user code에서 사용할 수 있는 counter 제공</li>
                                            <li> 각 worker들은 ping msg를 통해 master에게 counter 정보를 보내고, master가 취합해 종료후 알려준다.
                                                <ul>
                                                    <li> 재실행으로 인해 counter가 중복 계산 되지 않도록 master가 잘 취합한다.</li>
                                                </ul>
                                            </li>
                                        </ul>

                                        <!-- 
                                    NewPP limit report
                                    Cached time: 20220512042233
                                    Cache expiry: 86400
                                    Dynamic content: false
                                    CPU time usage: 0.012 seconds
                                    Real time usage: 0.019 seconds
                                    Preprocessor visited node count: 99/1000000
                                    Preprocessor generated node count: 104/1000000
                                    Post‐expand include size: 0/2097152 bytes
                                    Template argument size: 0/2097152 bytes
                                    Highest expansion depth: 2/40
                                    Expensive parser function count: 0/100
                                    -->
                                        <!--
                                    Transclusion expansion time report (%,ms,calls,template)
                                    100.00%    0.000      1 -total
                                    -->
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <footer class="grid site-footer">
        <p>&copy;&nbsp;Big Data Analytics Lab</p>
        <p>
            <small>Powered by
                <a href="http://jekyllrb.com" target="_blank"><em>Jekyll</em></a>
                using
                <a href="http://bitwiser.in/bitwiser/" target="_blank"><em>Bitwiser</em></a>
                theme.</small>
        </p>
    </footer>

    <script src="/js/script.js"></script>
</body>

</html>